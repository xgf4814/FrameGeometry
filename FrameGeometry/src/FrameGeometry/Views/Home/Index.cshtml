@model IEnumerable<FrameGeometry.Models.Geometry>

@{
    ViewData["Title"] = "Home Page";
    List<int> IDs = new List<int>();
}

<link rel="stylesheet" href="~/css/selectize.css">
<link rel="stylesheet" href="~/css/selectize.bootstrap3.css">
<script src="~/lib/jquery/dist/jquery.js"></script>
<script src="~/js/selectize.js"></script>
<script>var theme = 'bootstrap3';</script>

<br/>
<div class="control-group">
    <label for="select-tools">Bicycles:</label>
    <select id="select-tools" multiple placeholder="Pick a bicycle frame..."></select>
</div>

<canvas id="myCanvas" style="border:1px solid #eeeeee;"></canvas>
<script>

    var x = 0.0;
    var y = 0.0;
    function polar2cartesian(R, theta) {
        this.x = R * Math.cos(theta * Math.PI / 180.0);
        this.y = R * Math.sin(theta * Math.PI / 180.0);
    }

    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    var bbdrop;
    var stack;
    var reach;
    var wheelbase;
    var chainstay;
    var STA;
    var STL;
    var HTA;
    var HTL;
    var standover;
    var diameter;
    class BikeGeometry {
        constructor(bbdrop, stack, reach, wheelbase, chainstay, STA, STL, HTA, HTL, diameter, standover) {
            this.bbdrop = bbdrop;
            this.stack = stack;
            this.reach = reach;
            this.wheelbase = wheelbase;
            this.chainstay = chainstay;
            this.STA = STA;
            this.STL = STL;
            this.HTA = HTA;
            this.HTL = HTL;
            this.diameter = diameter;
            if (standover == undefined)
                standover = 0;
            else
                this.standover = standover;
        }
    }


    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');

    // resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    var value;
    function setValue(value_in) {
        value = value_in;
    }

    var eventHandler = function() {
        return function() {
            var test = selectizeControl.getValue();
            setValue(test);
            drawStuff();
            //alert("EventHandler");

        }
    };

    function resizeCanvas() {
        canvas.height = window.innerHeight * .8;
        var containers = document.getElementsByClassName("container");
        canvas.width = containers[1].clientWidth - 32;
        drawStuff();
        //eventHandler();
    }
    resizeCanvas();

    function clearCanvas() {
        canvas.height = window.innerHeight * .8;
        var containers = document.getElementsByClassName("container");
        canvas.width = containers[1].clientWidth - 32;    
    }

    var $select;
    var selectizeControl;




    function drawBike(context, scale_in, geometry, strokeStyle) {

        var scale = ((window.innerHeight > window.innerWidth) ? (window.innerWidth / 1400) : (window.innerHeight / 1400));
        var bbx = canvas.width / 2.2; //window.innerWidth / 2.2;
        var bby = canvas.height * .7 + (geometry.bbdrop * scale); //(window.innerHeight * 2 / 3) + (geometry.bbdrop * scale);
        var headTubeTopX = bbx + geometry.reach * scale;
        var headTubeTopY = bby - geometry.stack * scale;
        polar2cartesian((20 * scale), geometry.HTA);
        var headTubeAlmostTopX = headTubeTopX + x;
        var headTubeAlmostTopY = headTubeTopY + y;
        polar2cartesian(geometry.HTL * scale, geometry.HTA);
        var headTubeBottomX = headTubeTopX + x;
        var headTubeBottomY = headTubeTopY + y;
        polar2cartesian(geometry.chainstay * scale, (90 - (Math.acos(geometry.bbdrop / geometry.chainstay) * 180) / Math.PI));
        var RD_X = bbx - x;
        var RD_Y = bby - y;
        polar2cartesian(geometry.STL * scale, geometry.STA);
        var seatTubeTopX = bbx - x;
        var seatTubeTopY = bby - y;
        polar2cartesian(((geometry.STL - 20) * scale), geometry.STA);
        var seatTubeAlmostTopX = bbx - x;
        var seatTubeAlmostTopY = bby - y;
        var FD_X = RD_X + geometry.wheelbase * scale;
        var FD_Y = RD_Y;
        var standoverY = (RD_Y + (((geometry.diameter + 0)* scale)/2)) - ((geometry.standover) * scale);
        var m_toptube = (headTubeTopY - standoverY) / (headTubeTopX - bbx);
        var m_seattube = (seatTubeTopY - bby) / (seatTubeTopX - bbx);
        var x_intercept = ((standoverY - bby)) / (m_seattube - m_toptube);
        var y_intercept = m_seattube * x_intercept;
        x_intercept += bbx;
        y_intercept += bby;
        context.strokeStyle = strokeStyle;
        context.beginPath();
        context.moveTo(bbx, bby);
        context.lineTo(RD_X, RD_Y);

        if(geometry.standover == 0)
        {
            context.lineTo(seatTubeAlmostTopX, seatTubeAlmostTopY);
        } else {
            context.lineTo(x_intercept, y_intercept);

        }

        context.lineTo(headTubeTopX, headTubeTopY);
        context.lineTo(headTubeBottomX, headTubeBottomY);
        context.lineTo(bbx, bby);
        context.closePath();
        context.moveTo(bbx, bby);
        context.lineTo(seatTubeTopX, seatTubeTopY);
        context.moveTo(headTubeBottomX, headTubeBottomY);
        context.lineTo(FD_X, FD_Y);
        context.lineWidth = 10;
        context.stroke();

        // Draw the wheelbase
        context.beginPath();
        context.moveTo(RD_X, RD_Y);
        context.lineTo(FD_X, FD_Y);
        context.lineWidth = 1;
        context.stroke();

        // Draw the stack
        context.beginPath();
        context.moveTo(bbx, bby);
        context.lineTo(bbx, headTubeTopY);
        context.lineWidth = 1;
        context.stroke();

        // Draw the reach
        context.beginPath();
        context.moveTo(bbx, headTubeTopY);
        context.lineTo(headTubeTopX, headTubeTopY);
        context.lineWidth = 1;
        context.stroke();

    }


    $select = $('#select-tools').selectize({
        maxItems: null,
        valueField: 'id',
        labelField: 'title',
        searchField: 'title',
        options: [
            @foreach (Geometry bike in Model)
    {
        <text>
        { id: @(bike.ID), title: '@(bike.ToString())', url: 'http://framegeometry.azurewebsites.net'},
        </text>
    }
    ],
    create: false,
    //onItemAdd       : drawStuff(),
    //onItemRemove    : drawStuff()
    onItemAdd       : eventHandler(),
    onItemRemove    : eventHandler()
    });
    selectizeControl = $select[0].selectize;

    function drawStuff() {

        clearCanvas();

        //var test = selectizeControl.getValue();
        if(value != null){

            for (i = 0; i < value.length; i++) {
                @foreach (var item in Model)
                        {
                            <text>
                        if(@(item.ID) == value[i]){
                            var g = new BikeGeometry(@(item.bbdrop),@(item.stack),@(item.reach),@(item.wheelbase),@(item.chainstay),@(item.STA),@(item.STL),@(item.HTA),@(item.HTL),@(item.wheeldiameter),@(item.standover));
                            var rgb = hexToRgb("#@(item.color)");
                            drawBike(context, 1, g, "rgba(" + rgb["r"] + "," +rgb["g"] + "," + rgb["b"] + ",0.6)");
                        }
                            </text>
                        }
                }
        }


    }



</script>
